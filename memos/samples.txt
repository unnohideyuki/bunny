filename (oldname): description

sample010 (sample1) : Hello, World!
sample020 (sample2) : where clause
sample021 (sample2b) : where-let nesting 1
sample022 (sample2c) : where-let nesting 2 (with name hiding)
sample023 (sample2d) : where-letrec nesting
sample024 (sample2e) : closure conversion
sample040 (sample4) : Simple pattern matching
sample050 (sample5) : Pattern matching and recursive function
sample060 (sample6) : Free var (and closure conversion) (same as 024)
sample070 (sample7) : Letrec (very similar to 024)
sample071 (sample7b) : Letrec with a tricky name hiding.
sample090 (sample9) : first-class function
sample091 (sample9b) : Letrec (similar to 024, 070)
sample100 (test3) : do and bind for IO monad.
sample101 (test8d) : First passed sample of dictionary-passing style function.
sample102 (test8)
sample103 (test9) : testing (++)
sample104 (test9a) : Fixity resolution sample.
sample105 (test9b) : tcExpr for Case.
sample106 (test11e) : confirming (++)
sample107 (test11f) : modified version of foldr without let binding.
sample108 (test11h) : pattern matching in let bindings.
sample109 (test11g2) : foldr without pattern matching and free vars.
sample110 (test11g) : foldr without free vars
sample111 (test11d) : using Prelude.foldr 
sample112 (test11c) : preparation for a list comprehension
sample113 (test11) : list comprehension
sample114 (test11b) : list comprehension with polymorpic type.
sample115 (tqd - show) : qsort! qsort!
sample116 (tqd) : tqd!
sample117 (test12) : Integer addition.
sample118 (test13x) : show True/False
sample119 (test13b) : addComp :: (Eq a, Num a) => a -> a -> Bool
sample112 (test13c) : addComp in a where clause.

pending samples...
sample3.hs -- NG, bunnyc.exe: insts: Prelude.Num


